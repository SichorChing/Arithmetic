{"version":3,"sources":["webpack://arithmetic/webpack/universalModuleDefinition","webpack://arithmetic/webpack/bootstrap","webpack://arithmetic/./src/script/arithmetic.js","webpack://arithmetic/./src/script/stack.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAA4B;;AAErB;AACP;AACA,2BAA2B,8CAAK;AAChC,4BAA4B,8CAAK;AACjC;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;AC3MA;AAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC","file":"./script/arithmetic.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"arithmetic\"] = factory();\n\telse\n\t\troot[\"arithmetic\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/script/arithmetic.js\");\n","import Stack from './stack';\r\n\r\nexport class Math {\r\n    constructor() {\r\n        this.operand = new Stack();\r\n        this.operator = new Stack();\r\n        this.tempNum = '';\r\n        this.tempSym = '';\r\n    }\r\n    /**\r\n     * @description 递归表达式，优先计算括号中的内容并进行替换\r\n     * @param {String}\r\n     */\r\n    matchInBrackets(expression) {\r\n        const regInBrackets = /\\([\\+|\\-|\\*|\\/|\\.|\\d]+?\\)/g;\r\n        let expInBrackets = expression.match(regInBrackets);\r\n        if (expInBrackets) {\r\n            expInBrackets.forEach(element => {\r\n                const tempResualt = this.calculate(element.replace(/[\\(|\\)]/g, ''));\r\n                expression = expression.replace(element, tempResualt);\r\n            });\r\n        }\r\n        expInBrackets = expression.match(regInBrackets);\r\n        return expInBrackets ? this.matchInBrackets(expression) : expression;\r\n    }\r\n    /**\r\n     * @description 初步处理计算表达式，将优先级高的乘除运算和括号内的运算先计算出结果\r\n     * @param {String}\r\n     */\r\n    calculate(expression) {\r\n        // 先判断表达式中是否存在括号运算，如果有则递归计算出其中的值并替换表达式中的括号\r\n        expression = this.matchInBrackets(expression);\r\n        for (let i = expression.length - 1; 0 <= i; i--) {\r\n            const numReg = /[\\d|\\.]/;\r\n            let char = expression[i];\r\n            if (numReg.test(char)) {\r\n                this.tempNum = char + this.tempNum;\r\n                if (0 == i) {\r\n                    if (this.tempSym) {\r\n                        this.calculateMultiOrDivis(this.tempSym);\r\n                        this.tempSym = '';\r\n                    }\r\n                    if (this.tempNum) this.operand.push(this.tempNum);\r\n                    break;\r\n                }\r\n            } else {\r\n                if (0 == i) {\r\n                    if (this.tempSym) {\r\n                        this.calculateMultiOrDivis(this.tempSym);\r\n                        this.tempSym = '';\r\n                    }\r\n                    if (this.tempNum) this.operand.push(this.tempNum);\r\n                    this.operator.push(char);\r\n                    break;\r\n                }\r\n                if (this.tempSym) {\r\n                    this.calculateMultiOrDivis(this.tempSym);\r\n                    this.tempSym = '';\r\n                }\r\n                let peekSym = this.operator.peek();\r\n                const nextChar = expression[i - 1];\r\n                const isSymbol = /[\\+|\\-|\\*|\\/]/;\r\n                if (peekSym) {\r\n                    if (this.tempNum) {\r\n                        if (isSymbol.test(nextChar) && '-' == char) {\r\n                            this.operand.push(char + this.tempNum);\r\n                            char = '';\r\n                        } else {\r\n                            this.operand.push(this.tempNum);\r\n                        }\r\n                        this.tempNum = '';\r\n                    }\r\n                    switch (Math.priorityCompare(peekSym, char)) {\r\n                        case 2:\r\n                            this.tempSym = this.operator.pop();\r\n                            break;\r\n                        case 1:\r\n                            this.calculateMultiOrDivis(this.operator.pop());\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                } else if (!peekSym && this.tempNum) {\r\n                    if (isSymbol.test(nextChar) && '-' == char) {\r\n                        this.operand.push(char + this.tempNum);\r\n                        char = '';\r\n                    } else {\r\n                        this.operand.push(this.tempNum);\r\n                    }\r\n                    this.tempNum = '';\r\n                }\r\n                if (char) this.operator.push(char);\r\n            }\r\n        }\r\n        return this.calculateReversePoland();\r\n    }\r\n    /**\r\n     * @description 计算最终的逆波兰表达式\r\n     */\r\n    calculateReversePoland() {\r\n        let resualt = 0;\r\n        while (0 < this.operand.getLength()) {\r\n            if (this.operator.getLength() == this.operand.getLength()) {\r\n                const symL = resualt;\r\n                const symR = this.operand.pop();\r\n                const cacheSym = this.operator.pop();\r\n                resualt = '+' == cacheSym ? Math.addition(symL, symR) : Math.subtraction(symL, symR);\r\n            } else {\r\n                if (1 == this.operand.getLength()) {\r\n                    resualt = parseFloat(this.operand.pop());\r\n                    break;\r\n                }\r\n                const symL = this.operand.pop();\r\n                const symR = this.operand.pop();\r\n                const cacheSym = this.operator.pop();\r\n                resualt = Math.selectCalculationRule(symL, symR, cacheSym);\r\n            }\r\n            this.operand.push(resualt);\r\n        }\r\n        this.operand.reset();\r\n        this.operator.reset();\r\n        this.tempNum = '';\r\n        this.tempSym = '';\r\n        return resualt;\r\n    }\r\n    /**\r\n     * @description 只计算乘法或者除法\r\n     * @param {String} sym\r\n     */\r\n    calculateMultiOrDivis(sym) {\r\n        const symL = this.operand.pop();\r\n        const symR = this.operand.pop();\r\n        this.operand.push(Math.selectCalculationRule(symL, symR, sym));\r\n        return undefined;\r\n    }\r\n    /**\r\n     * @description 判断两个数字间的运算法则\r\n     * @param {String || Number} symL\r\n     * @param {String || Number} symR\r\n     * @param {String} sym\r\n     */\r\n    static selectCalculationRule(symL, symR, sym) {\r\n        switch (sym) {\r\n            case '*':\r\n                return Math.multiplication(symL, symR);\r\n            case '/':\r\n                return Math.division(symL, symR);\r\n            case '+':\r\n                return Math.addition(symL, symR);\r\n            default:\r\n                return Math.subtraction(symL, symR);\r\n        }\r\n    }\r\n    /**\r\n     * @description 加法\r\n     * @param {String || Number}\r\n     */\r\n    static addition(...num) {\r\n        const symL = parseFloat(num[0]);\r\n        const symR = parseFloat(num[1]);\r\n        return symL + symR;\r\n    }\r\n    /**\r\n     * @description 除法\r\n     * @param {String || Number}\r\n     */\r\n    static division(...num) {\r\n        const symL = parseFloat(num[0]);\r\n        const symR = parseFloat(num[1]);\r\n        return symL / symR;\r\n    }\r\n    /**\r\n     * @description 乘法\r\n     * @param {String || Number}\r\n     */\r\n    static multiplication(...num) {\r\n        const symL = parseFloat(num[0]);\r\n        const symR = parseFloat(num[1]);\r\n        return symL * symR;\r\n    }\r\n    /**\r\n     * @description 减法\r\n     * @param {String || Number}\r\n     */\r\n    static subtraction(...num) {\r\n        const symL = parseFloat(num[0]);\r\n        const symR = parseFloat(num[1]);\r\n        return symL - symR;\r\n    }\r\n    /**\r\n     * @description 判断两个运算符的优先级\r\n     * @param {String}\r\n     */\r\n    static priorityCompare(symA, symB) {\r\n        const high = /[\\*\\/]/;\r\n        if (high.test(symA) && !high.test(symB)) {\r\n            return 2;\r\n        } else if (high.test(symA) && high.test(symB)) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n};\r\n","export default class {\r\n    constructor() {\r\n        this.stack = [];\r\n    }\r\n\r\n    getLength() {\r\n        return this.stack.length;\r\n    }\r\n\r\n    peek() {\r\n        const len = this.getLength();\r\n        return len ? this.stack[len - 1] : undefined;\r\n    }\r\n\r\n    pop() {\r\n        return this.stack.pop();\r\n    }\r\n\r\n    push(num) {\r\n        this.stack.push(num);\r\n        return undefined;\r\n    }\r\n\r\n    reset() {\r\n        this.stack = [];\r\n        return undefined;\r\n    }\r\n};\r\n"],"sourceRoot":""}